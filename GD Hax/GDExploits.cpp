#include "GDExploits.hpp"

// completely revamped stat system, a lot of the struct info and names are guessed
// Address: GeometryDash.exe+0x43C110 (Windows GD Version 2.203)
stat_edits::StatLinkedList* stat_edits::get_stat_addr(driver& game, StatInfo* instance, StatType stat) {
    unsigned int hash = hash_number(game, instance, reinterpret_cast<PUINT8>(&stat));
    int v5 = game.read<int>(&instance->stat_table);
    DWORD* v6 = game.read<DWORD*>(&instance->unk1);
    DWORD** v8 = reinterpret_cast<DWORD**>(v5 + 8 * hash);
    StatLinkedList* linked_list = game.read<StatLinkedList*>(v8);
    DWORD* v9 = nullptr;

    while (true)
    {
        if (game.read<DWORD*>(v8) == v6)
            v9 = v6;
        else
            v9 = game.read<DWORD*>( game.read<DWORD**>(&v8[1]) );

        if (reinterpret_cast<DWORD*>(linked_list) == v9)
            return nullptr;

        if (game.read<StatType>(&linked_list->stat) == stat)
            return linked_list;

        linked_list = game.read<StatLinkedList*>(&linked_list->next);
    }
}

// hash number using fnv32 algorithm (algo used in many games bc of how fast it generates hashes)
unsigned int stat_edits::hash_number(driver& game, StatInfo* instance, PUINT8 number) {
    const UINT mask = game.read<UINT>(&instance->hash_mask);
    UINT hash = 0x811C9DC5;
    const UINT prime = 0x1000193;

    // normally this algo is used with strings, but rob uses it to hash ints so the length is hardcoded to 4
    for (int i = 0; i < 4; ++i) {
        hash ^= number[i];
        hash *= prime;
    }

    UINT result = hash & mask;
    UINT unk = game.read<UINT>(&instance->hash_info_unk);
    if (unk > result)
        return result;
    else
        return 0xFFFFFFFF - (mask >> 1) + result;
}