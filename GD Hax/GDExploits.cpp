#include "GDExploits.hpp"

// completely revamped stat system (again), a lot of the struct info and names are guessed
// Address: GeometryDash.exe+0x1D21E0 (Windows GD Version 2.207)
stat_edits::StatLinkedList* stat_edits::get_stat_addr(driver& game, StatInfo* instance, StatType stat) {
    uint64_t hash = hash_number(game, instance, reinterpret_cast<uint8_t*>(&stat));
    StatLinkedList** stat_table = game.read<StatLinkedList**>(&instance->stat_table);
    StatLinkedList* cur = game.read<StatLinkedList*>(&stat_table[hash + 1]);
    void* end = game.read<void*>(&instance->list_end);

    if (cur == end)
        return nullptr;

    StatLinkedList* v12 = game.read<StatLinkedList*>(&stat_table[hash]);
    if (stat != game.read<StatType>(&cur->stat)) {
        while (cur != v12) {
            cur = game.read<StatLinkedList*>(&cur->next);
            if (stat == game.read<StatType>(&cur->stat))
                break;
        }
    }

    return cur;
    /* there is more code beyond this, but it all seems to be logic for adding new items to the hashtable, so im not gonna bother */
}

// hash number using fnv64-1a algorithm (algo used in many games bc of how fast it generates hashes)
uint64_t stat_edits::hash_number(driver& game, StatInfo* instance, uint8_t* number) {
    const uint64_t mask = game.read<uint64_t>(&instance->hash_mask);
    uint64_t hash = 0xCBF29CE484222325;
    const uint64_t prime = 0x100000001B3;

    // normally this algo is used with strings, but rob uses it to hash ints so the length is hardcoded to 4
    for (int i = 0; i < 4; ++i) {
        hash ^= number[i];
        hash *= prime;
    }

    uint64_t result = hash & mask;
    return 2 * result;
}